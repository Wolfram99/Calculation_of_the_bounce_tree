<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" th:href="@{/webjars/bootstrap/5.3.2/css/bootstrap.min.css}"/>
    <link rel="stylesheet" type="text/css" th:href="@{/css_custom/css_custom.css}">

    <title>Wires</title>

    <!-- Loads and initializes the library -->
    <script th:src="@{/js/mxClient.js}"></script>
    <script type="text/javascript">
        // If connect preview is not moved away then getCellAt is used to detect the cell under
        // the mouse if the mouse is over the preview shape in IE (no event transparency), ie.
        // the built-in hit-detection of the HTML document will not be used in this case.
        mxConnectionHandler.prototype.movePreviewAway = false;
        mxConnectionHandler.prototype.waypointsEnabled = true;
        mxGraph.prototype.resetEdgesOnConnect = false;
        mxConstants.SHADOWCOLOR = '#C0C0C0';
        var joinNodeSize = 7;
        var strokeWidth = 2;

        // Replaces the port image
        mxConstraintHandler.prototype.pointImage = new mxImage('images/dot.gif', 10, 10);

        // Enables guides
        mxGraphHandler.prototype.guidesEnabled = true;

        // Alt disables guides
        mxGuide.prototype.isEnabledForEvent = function (evt) {
            return !mxEvent.isAltDown(evt);
        };

        // Enables snapping waypoints to terminals
        mxEdgeHandler.prototype.snapToTerminals = true;

        function main(container) {
            var graph = new mxGraph(container);
            graph.view.scale = 1;
            graph.setPanning(true);
            graph.setConnectable(true);
            graph.setConnectableEdges(false);
            graph.setDisconnectOnMove(false);
            graph.foldingEnabled = false;

            //Maximum size
            graph.maximumGraphBounds = new mxRectangle(0, 0, 2400, 2400);
            graph.border = 50;

            // Panning handler consumed right click so this must be
            // disabled if right click should stop connection handler.
            graph.panningHandler.isPopupTrigger = function () {
                return false;
            };

            // Enables return key to stop editing (use shift-enter for newlines)
            graph.setEnterStopsCellEditing(true);

            // Adds rubberband selection
            new mxRubberband(graph);

            // Alternative solution for implementing connection points without child cells.
            // This can be extended as shown in portrefs.html example to allow for per-port
            // incoming/outgoing direction.
            graph.getAllConnectionConstraints = function (terminal) {
                var geo = (terminal != null) ? this.getCellGeometry(terminal.cell) : null;

                if ((geo != null ? !geo.relative : false) &&
                    this.getModel().isVertex(terminal.cell) &&
                    this.getModel().getChildCount(terminal.cell) == 0) {
                    return [new mxConnectionConstraint(new mxPoint(0, 0.5), false),
                        new mxConnectionConstraint(new mxPoint(1, 0.5), false)];
                }

                return null;
            };



            ///////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////


            new mxKeyHandler(graph);

            // Overrides method to provide a cell label in the display
            graph.convertValueToString = function (cell) {
                if (mxUtils.isNode(cell.value)) {
                    if (cell.value.nodeName.toLowerCase() == 'ref') {
                        var refText = cell.getAttribute('refText', '');
                        var lambda = cell.getAttribute('lambda', '');


                        return refText + '\n' + lambda;
                    } else if (cell.value.nodeName.toLowerCase() == 'amount') {
                        var result = cell.getAttribute('Result', '');
                        var refText = cell.getAttribute('refText', '');



                        return refText + '\n' + result;
                    } else {
                        return cell.value.nodeName;
                    }

                }

                return cell.value;
            };

            // Overrides method to store a cell label in the model
            var cellLabelChanged = graph.cellLabelChanged;
            graph.cellLabelChanged = function (cell, newValue, autoSize) {
                if (mxUtils.isNode(cell.value)) {
                    if (cell.value.nodeName.toLowerCase() == 'ref' || cell.value.nodeName.toLowerCase() == 'amount') {
                        // var pos = newValue.indexOf(' ');
                        var pos = newValue.length;
                        var refText = (pos > 0) ? newValue.substring(0,
                            pos) : newValue;

                        // Clones the value for correct undo/redo
                        var elt = cell.value.cloneNode(true);

                        elt.setAttribute('refText', '\u2003'+refText+'\u2003');

                        newValue = elt;
                        autoSize = true;

                    }
                } else if (mxUtils.isNode(cell.value) && this.graph.getModel().isEdge(cell)) {
                    var pos = newValue.indexOf(' ');

                    var refText = (pos > 0) ? newValue.substring(0,
                        pos) : newValue;

                    // Clones the value for correct undo/redo
                    var elt = cell.value.cloneNode(true);

                    elt.setAttribute('value', refText);

                    newValue = elt;
                    autoSize = true;
                }

                cellLabelChanged.apply(this, arguments);
            };

            // Overrides method to create the editing value
            var getEditingValue = graph.getEditingValue;
            graph.getEditingValue = function(cell)
            {
                if (mxUtils.isNode(cell.value
                    ) &&
                    cell.value.nodeName.toLowerCase() == 'ref')
                {
                    var refText = cell.getAttribute('refText', '');

                    return refText;
                }
            };

            ///////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////////////////////

            // Makes sure non-relative cells can only be connected via constraints
            graph.connectionHandler.isConnectableCell = function (cell) {
                if (this.graph.getModel().isEdge(cell)) {
                    return true;
                } else {
                    var geo = (cell != null) ? this.graph.getCellGeometry(cell) : null;

                    return (geo != null) ? geo.relative : false;
                }
            };
            mxEdgeHandler.prototype.isConnectableCell = function (cell) {
                return graph.connectionHandler.isConnectableCell(cell);
            };

            // Adds a special tooltip for edges
            graph.setTooltips(true);

            var getTooltipForCell = graph.getTooltipForCell;
            graph.getTooltipForCell = function (cell) {
                var tip = '';

                if (cell != null) {
                    var src = this.getModel().getTerminal(cell, true);

                    if (src != null) {
                        tip += this.getTooltipForCell(src) + ' ';
                    }

                    var parent = this.getModel().getParent(cell);

                    if (this.getModel().isVertex(parent)) {
                        tip += this.getTooltipForCell(parent) + '.';
                    }

                    tip += getTooltipForCell.apply(this, arguments);

                    var trg = this.getModel().getTerminal(cell, false);

                    if (trg != null) {
                        tip += ' ' + this.getTooltipForCell(trg);
                    }
                }

                return tip;
            };

            // Switch for black background and bright styles
            var invert = false;

            if (invert) {
                container.style.backgroundColor = 'black';

                // White in-place editor text color
                mxCellEditorStartEditing = mxCellEditor.prototype.startEditing;
                mxCellEditor.prototype.startEditing = function (cell, trigger) {
                    mxCellEditorStartEditing.apply(this, arguments);

                    if (this.textarea != null) {
                        this.textarea.style.color = '#FFFFFF';
                    }
                };

                mxGraphHandler.prototype.previewColor = 'white';
            }

            var labelBackground = (invert) ? '#000000' : '#FFFFFF';
            var fontColor = (invert) ? '#FFFFFF' : '#000000';
            var strokeColor = (invert) ? '#C0C0C0' : '#000000';
            var fillColor = (invert) ? 'none' : '#FFFFFF';

            var style = graph.getStylesheet().getDefaultEdgeStyle();
            delete style['endArrow'];
            style['strokeColor'] = strokeColor;
            style['labelBackgroundColor'] = labelBackground;
            style['edgeStyle'] = 'wireEdgeStyle';
            style['fontColor'] = fontColor;
            style['fontSize'] = '9';
            style['movable'] = '0';
            style['labelBorderColor'] = 'black';
            style['strokeWidth'] = strokeWidth;
            //style['rounded'] = '1';

            // Sets join node size
            style['startSize'] = joinNodeSize;
            style['endSize'] = joinNodeSize;

            style = graph.getStylesheet().getDefaultVertexStyle();
            style['gradientDirection'] = 'south';
            //style['gradientColor'] = '#909090';
            style['strokeColor'] = strokeColor;
            //style['fillColor'] = '#e0e0e0';
            style['fillColor'] = 'none';
            style['fontColor'] = fontColor;
            style['fontStyle'] = '1';
            style['fontSize'] = '12';
            style['resizable'] = '0';

            style['rounded'] = '1';
            style['strokeWidth'] = strokeWidth;

            var ind = 0;

            function create_Result() {
                var doc = mxUtils.createXmlDocument();
                var field = doc.createElement('AMOUNT');
                field.setAttribute("Result", '0.0');
                field.setAttribute('refText', 'Сумма отказов');

                var result = graph.insertVertex(parent, null, field, 0, 0, 100, 40);
                result.setConnectable(false);

                //cross, line,
                var result_in = graph.insertVertex(result, null, 'in', 0.47, 1, 5, 5,
                    'shape=;align=right;verticalAlign=middle;fontSize=10;routingCenterX=0;' +
                    'spacingRight=10;verticalLabelPosition=bottom;verticalAlign=top;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                result_in.geometry.relative = true;
                result_in.geometry.offset = new mxPoint(result_in.geometry.high, 0);

                ind++;
                return result;
            }


            function create_AND() {

                var doc = mxUtils.createXmlDocument();
                var field = doc.createElement('AND');
                field.setAttribute('T', 1);

                var and = graph.insertVertex(parent, null, field, 0, 0, 90, 90, 'shape=image;image=images/logic/AND1_ANSI.svg.png;');
                and.setConnectable(false);

                //cross, line,
                var and_in1 = graph.insertVertex(and, null, 'in1', 0.37, 1, 5, 5,
                    'shape=;align=right;verticalAlign=middle;fontSize=10;routingCenterX=0.5;' +
                    'spacingRight=12;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                and_in1.geometry.relative = true;
                and_in1.geometry.offset = new mxPoint(and_in1.geometry.high, -4);


                var and_in2 = graph.insertVertex(and, null, 'in2', 0.57, 1, 5, 5,
                    'shape=;align=;verticalAlign=middle;fontSize=10;routingCenterX=-0.5;' +
                    'spacingLeft=12;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                and_in2.geometry.relative = true;
                and_in2.geometry.offset = new mxPoint(and_in2.geometry.high, -4); //СѓРїСЂР°РІР»СЏРµС‚ СЂР°СЃРїРѕР»РѕР¶РµРЅРёРµРј

                var and_out = graph.insertVertex(and, null, 'out', 0.47, 0, 5, 5,
                    'shape=;align=;verticalAlign=middle;fontSize=10;routingCenterX=-0.5;' +
                    'spacingLeft=12;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                and_out.geometry.relative = true;
                and_out.geometry.offset = new mxPoint(and_out.geometry.high, 0); //СѓРїСЂР°РІР»СЏРµС‚ Р»РµР№Р±Р»РѕРј
                ind++;
                return and;
            }

            function create_OR() {

                var doc = mxUtils.createXmlDocument();
                var field = doc.createElement('OR');

                var or = graph.insertVertex(parent, null, field, 0, 0, 90, 90, 'shape=image;image=images/logic/OR1_ANSI.svg.png');
                or.setConnectable(false);

                //cross, line,
                var or_in1 = graph.insertVertex(or, null, 'in1', 0.37, 1, 5, 5,
                    'shape=;align=right;verticalAlign=middle;fontSize=10;routingCenterX=0.5;' +
                    'spacingRight=12;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                or_in1.geometry.relative = true;
                or_in1.geometry.offset = new mxPoint(or_in1.geometry.high, -4);


                var or_in2 = graph.insertVertex(or, null, 'in2', 0.57, 1, 5, 5,
                    'shape=;align=;verticalAlign=middle;fontSize=10;routingCenterX=-0.5;' +
                    'spacingLeft=12;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                or_in2.geometry.relative = true;
                or_in2.geometry.offset = new mxPoint(or_in2.geometry.high, -4);

                var or_out = graph.insertVertex(or, null, 'out', 0.47, 0, 5, 5,
                    'shape=;align=;verticalAlign=middle;fontSize=10;routingCenterX=-0.5;' +
                    'spacingLeft=12;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                or_out.geometry.relative = true;
                or_out.geometry.offset = new mxPoint(or_out.geometry.high, 0);

                return or;
            }

            function create_Refusal() {

                var doc = mxUtils.createXmlDocument();
                var field = doc.createElement('REF');
                field.setAttribute('lambda', '0.0');
                field.setAttribute('refText', 'Блок отказа');

                var refusal = graph.insertVertex(parent, null, field, 0, 0, 100, 40, 'rounded=0;');
                refusal.setConnectable(false);


                var refusal_out = graph.insertVertex(refusal, null, 'out', 0.47, 0, 5, 5,
                    'shape=;align=;verticalAlign=middle;fontSize=10;routingCenterX=-0.5;' +
                    'spacingLeft=10;verticalLabelPosition=;verticalAlign=bottom;whiteSpace=wrap;' +
                    'fontColor=' + fontColor + ';strokeColor=' + strokeColor);
                refusal_out.geometry.relative = true;
                refusal_out.geometry.offset = new mxPoint(refusal_out.geometry.high, -5);

                return refusal;
            }

            function selectionChanged(graph) {
                var div = document.getElementById('properties');

                // Отключает фокусировку в IE
                graph.container.focus();

                // Очищает DIV способом, отличным от DOM
                div.innerHTML = '';

                // Возвращает ячейку выделения
                var cell = graph.getSelectionCell();
                if (cell == null || cell.isEdge()) {
                    cell = null;
                    mxUtils.writeln(div, 'Nothing selected.');
                } else {
                    // Записывает заголовок
                    var center = document.createElement('center');
                    mxUtils.writeln(center, cell.value.nodeName); // + ' (' + cell.id + ')'
                    div.appendChild(center);
                    mxUtils.br(div);

                    // Создает форму на основе атрибутов пользовательского объекта
                    var form = new mxForm();

                    var attrs = cell.value.attributes;

                    for (var i = 0; i < attrs.length; i++) {
                        // тут нужно сделать проверку котоая будет сосздавать
                        createTextField(graph, form, cell, attrs[i]);
                    }

                    div.appendChild(form.getTable());

                    // Создание кнопки для открытия модального окна
                    // которое содежит в себе информацию выгруженную из БД
                    if (cell.value.nodeName.startsWith('REF')) {
                        var modalText = form.addText('');
                        modalText.setAttribute("id", 'button_' + cell.value.nodeName + '_' + cell.id);
                        modalText.value = "загрузить";
                        modalText.setAttribute("type", "button");
                        modalText.setAttribute("class", "col-md btn btn-outline-success btn-sm start-button");
                        modalText.setAttribute("data-bs-toggle", "modal");
                        modalText.setAttribute("data-bs-target", "#exampleModal");
                        modalText.setAttribute("onclick", "parseTable()");

                        div.appendChild(modalText);
                    }
                    mxUtils.br(div);
                }
            }

            function createTextField(graph, form, cell, attribute) {
                var input;
                if (attribute.nodeName == 'lambda') {
                    input = form.addText('Значение блока отказа:', attribute.nodeValue);
                } else if (attribute.nodeName == 'refText') {
                    input = form.addText('', attribute.nodeValue);
                    input.setAttribute('hidden','hidden');
                    input.setAttribute('readonly','readonly');
                } else if (attribute.nodeName == 'Result') {
                    input = form.addText('Результат:', attribute.nodeValue);
                } else {
                    input = form.addText(attribute.nodeName + ':', attribute.nodeValue);
                }
                input.setAttribute("id", attribute.nodeName);
                input.setAttribute("class", "form-control");

                var applyHandler = function () {
                    var newValue = input.value || '';
                    var oldValue = cell.getAttribute(attribute.nodeName, '');

                    if (newValue != oldValue) {
                        graph.getModel().beginUpdate();

                        try {
                            var edit = new mxCellAttributeChange(
                                cell, attribute.nodeName,
                                newValue);
                            graph.getModel().execute(edit);
                            // graph.updateCellSize(cell);
                        } finally {
                            graph.getModel().endUpdate();
                        }
                    }
                };

                mxEvent.addListener(input, 'keypress', function (evt) {
                    // Необходимо учитывать сдвиг для текстовых областей
                    if (evt.keyCode == /*enter*/13 &&
                        !mxEvent.isShiftDown(evt)) {
                        input.blur();
                    }
                });

                if (mxClient.IS_IE) {
                    mxEvent.addListener(input, 'focusout', applyHandler);
                } else {
                    // Примечание: Известной проблемой является размытие полей в
                    // Firefox при изменении выделения, и в этом случае
                    // в FF не запускается событие, и изменение теряется.
                    // В качестве обходного пути вам следует использовать локальную переменную
                    //, которая сохраняет сфокусированное поле и вызывает размытие
                    // // явно там, где мы строим график.сосредоточьтесь выше.
                    mxEvent.addListener(input, 'blur', applyHandler);
                }
            }

            var parent = graph.getDefaultParent();

            graph.getModel().beginUpdate();

            try {

            } finally {
                graph.getModel().endUpdate();
            }

            graph.getSelectionModel().addListener(mxEvent.CHANGE, function (sender, evt) {
                selectionChanged(graph);
            });

            selectionChanged(graph);

            var zoom_in = document.body.appendChild(mxUtils.button('Zoom In', function () {
                graph.zoomIn();
            }));
            zoom_in.setAttribute("class", "btn btn-outline-success ");

            var zoom_out = document.body.appendChild(mxUtils.button('Zoom Out', function () {
                graph.zoomOut();
            }));
            zoom_out.setAttribute("class", "btn btn-outline-success");

            // Undo/redo
            var undoManager = new mxUndoManager();
            var listener = function (sender, evt) {
                undoManager.undoableEditHappened(evt.getProperty('edit'));
            };
            graph.getModel().addListener(mxEvent.UNDO, listener);
            graph.getView().addListener(mxEvent.UNDO, listener);

            var undo = document.body.appendChild(mxUtils.button('Назад', function () {
                undoManager.undo();
            }));
            undo.setAttribute("class", "btn btn-outline-success");

            var redo = document.body.appendChild(mxUtils.button('Вперёд', function () {
                undoManager.redo();
            }));
            redo.setAttribute("class", "btn btn-outline-success");

            var remove_cells = document.body.appendChild(mxUtils.button('Удалить', function () {
                graph.removeCells();
            }));
            remove_cells.setAttribute("class", "btn btn-outline-success");

            var create_and_button = document.body.appendChild(mxUtils.button('Блок AND', function () {
                create_AND();
            }));
            create_and_button.setAttribute("class", "btn btn-outline-success");

            var create_or_button = document.body.appendChild(mxUtils.button('Блок OR', function () {
                create_OR();
            }));
            create_or_button.setAttribute("class", "btn btn-outline-success");


            var create_refusal_button = document.body.appendChild(mxUtils.button('Блок отказа', function () {
                create_Refusal();
            }));
            create_refusal_button.setAttribute("class", "btn btn-outline-success");

            var create_amount_button = document.body.appendChild(mxUtils.button('Блок результата', function () {
                create_Result();
            }));
            create_amount_button.setAttribute("class", "btn btn-outline-success");


            // var button = mxUtils.button('View XML', function () {
            //     var encoder = new mxCodec();
            //     var node = encoder.encode(graph.getModel());
            //     mxUtils.popup(mxUtils.getPrettyXml(node), true);
            // });
            // document.body.appendChild(button, container.nextSibling);

            var button = mxUtils.button('Расчёт', function () {
                var encoder = new mxCodec();
                var node = encoder.encode(graph.getModel());
                var cells = graph.getCells(0, 0, graph.getMaximumGraphBounds().width, graph.getMaximumGraphBounds().height, parent);
                for (var i = 0; i < cells.length; i++) {
                    if (cells[i].value.nodeName != undefined && ((cells[i].value.nodeName == "AMOUNT") || (cells[i].value.nodeName == "Amount"))) {

                        graph.selectCellForEvent(cells[i], mxEvent.SELECT);
                        parseAmount(mxUtils.getPrettyXml(node));

                        break;
                    }
                }
            });

            var sum_button = document.body.appendChild(button, container.nextSibling);
            sum_button.setAttribute("class", "btn btn-outline-success");

            // Avoids any connections for gestures within tolerance except when in wire-mode
            // or when over a port
            var connectionHandlerMouseUp = graph.connectionHandler.mouseUp;
            graph.connectionHandler.mouseUp = function (sender, me) {
                if (this.first != null && this.previous != null) {
                    var point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
                    var dx = Math.abs(point.x - this.first.x);
                    var dy = Math.abs(point.y - this.first.y);

                    if (dx < this.graph.tolerance && dy < this.graph.tolerance) {
                        // Selects edges in non-wire mode for single clicks, but starts
                        // connecting for non-edges regardless of wire-mode
                        if (this.graph.getModel().isEdge(this.previous.cell)) {
                            this.reset();
                        }

                        return;
                    }
                }

                connectionHandlerMouseUp.apply(this, arguments);
            };
        }

    </script>
    <!--
            Updates connection points before the routing is called.
    -->
    <script type="text/javascript">
        // Computes the position of edge to edge connection points.
        mxGraphView.prototype.updateFixedTerminalPoint = function (edge, terminal, source, constraint) {
            var pt = null;

            if (constraint != null) {
                pt = this.graph.getConnectionPoint(terminal, constraint);
            }

            if (source) {
                edge.sourceSegment = null;
            } else {
                edge.targetSegment = null;
            }

            if (pt == null) {
                var s = this.scale;
                var tr = this.translate;
                var orig = edge.origin;
                var geo = this.graph.getCellGeometry(edge.cell);
                pt = geo.getTerminalPoint(source);

                // Computes edge-to-edge connection point
                if (pt != null) {
                    pt = new mxPoint(s * (tr.x + pt.x + orig.x),
                        s * (tr.y + pt.y + orig.y));

                    // Finds nearest segment on edge and computes intersection
                    if (terminal != null && terminal.absolutePoints != null) {
                        var seg = mxUtils.findNearestSegment(terminal, pt.x, pt.y);

                        // Finds orientation of the segment
                        var p0 = terminal.absolutePoints[seg];
                        var pe = terminal.absolutePoints[seg + 1];
                        var horizontal = (p0.x - pe.x == 0);

                        // Stores the segment in the edge state
                        var key = (source) ? 'sourceConstraint' : 'targetConstraint';
                        var value = (horizontal) ? 'horizontal' : 'vertical';
                        edge.style[key] = value;

                        // Keeps the coordinate within the segment bounds
                        if (horizontal) {
                            pt.x = p0.x;
                            pt.y = Math.min(pt.y, Math.max(p0.y, pe.y));
                            pt.y = Math.max(pt.y, Math.min(p0.y, pe.y));
                        } else {
                            pt.y = p0.y;
                            pt.x = Math.min(pt.x, Math.max(p0.x, pe.x));
                            pt.x = Math.max(pt.x, Math.min(p0.x, pe.x));
                        }
                    }
                }
                // Computes constraint connection points on vertices and ports
                else if (terminal != null && terminal.cell.geometry.relative) {
                    pt = new mxPoint(this.getRoutingCenterX(terminal),
                        this.getRoutingCenterY(terminal));
                }

                // Snaps point to grid
                // if (pt != null)
                // {
                //     var tr = this.graph.view.translate;
                //     var s = this.graph.view.scale;
                //
                //     pt.x = (this.graph.snap(pt.x / s - tr.x) + tr.x) * s;
                //     pt.y = (this.graph.snap(pt.y / s - tr.y) + tr.y) * s;
                // }
            }

            edge.setAbsoluteTerminalPoint(pt, source);
        };
    </script>
    <!--
        Overrides methods to preview and create new edges.
    -->
    <script type="text/javascript">
        // Sets source terminal point for edge-to-edge connections.
        mxConnectionHandler.prototype.createEdgeState = function (me) {
            var edge = this.graph.createEdge();
            edge.value = 'Отказ';

            if (this.sourceConstraint != null && this.previous != null) {
                edge.style = mxConstants.STYLE_EXIT_X + '=' + this.sourceConstraint.point.x + ';' +
                    mxConstants.STYLE_EXIT_Y + '=' + this.sourceConstraint.point.y + ';';
            } else if (this.graph.model.isEdge(me.getCell())) {
                var scale = this.graph.view.scale;
                var tr = this.graph.view.translate;
                var pt = new mxPoint(this.graph.snap(me.getGraphX() / scale) - tr.x,
                    this.graph.snap(me.getGraphY() / scale) - tr.y);
                edge.geometry.setTerminalPoint(pt, true);
            }

            return this.graph.view.createState(edge);
        };

        // Uses right mouse button to create edges on background (see also: lines 67 ff)
        mxConnectionHandler.prototype.isStopEvent = function (me) {
            return me.getState() != null || mxEvent.isRightMouseButton(me.getEvent());
        };

        // Updates target terminal point for edge-to-edge connections.
        mxConnectionHandlerUpdateCurrentState = mxConnectionHandler.prototype.updateCurrentState;
        mxConnectionHandler.prototype.updateCurrentState = function (me) {
            mxConnectionHandlerUpdateCurrentState.apply(this, arguments);

            if (this.edgeState != null) {
                this.edgeState.cell.geometry.setTerminalPoint(null, false);

                if (this.shape != null && this.currentState != null &&
                    this.currentState.view.graph.model.isEdge(this.currentState.cell)) {
                    var scale = this.graph.view.scale;
                    var tr = this.graph.view.translate;
                    var pt = new mxPoint(this.graph.snap(me.getGraphX() / scale) - tr.x,
                        this.graph.snap(me.getGraphY() / scale) - tr.y);
                    this.edgeState.cell.geometry.setTerminalPoint(pt, false);
                }
            }
        };

        // Updates the terminal and control points in the cloned preview.
        mxEdgeSegmentHandler.prototype.clonePreviewState = function (point, terminal) {
            var clone = mxEdgeHandler.prototype.clonePreviewState.apply(this, arguments);
            clone.cell = clone.cell.clone();

            if (this.isSource || this.isTarget) {
                clone.cell.geometry = clone.cell.geometry.clone();

                // Sets the terminal point of an edge if we're moving one of the endpoints
                if (this.graph.getModel().isEdge(clone.cell)) {
                    // TODO: Only set this if the target or source terminal is an edge
                    clone.cell.geometry.setTerminalPoint(point, this.isSource);
                } else {
                    clone.cell.geometry.setTerminalPoint(null, this.isSource);
                }
            }

            return clone;
        };

        var mxEdgeHandlerConnect = mxEdgeHandler.prototype.connect;
        mxEdgeHandler.prototype.connect = function (edge, terminal, isSource, isClone, me) {
            var result = null;
            var model = this.graph.getModel();
            var parent = model.getParent(edge);

            model.beginUpdate();
            try {
                result = mxEdgeHandlerConnect.apply(this, arguments);
                var geo = model.getGeometry(result);

                if (geo != null) {
                    geo = geo.clone();
                    var pt = null;

                    if (model.isEdge(terminal)) {
                        pt = this.abspoints[(this.isSource) ? 0 : this.abspoints.length - 1];
                        pt.x = pt.x / this.graph.view.scale - this.graph.view.translate.x;
                        pt.y = pt.y / this.graph.view.scale - this.graph.view.translate.y;

                        var pstate = this.graph.getView().getState(
                            this.graph.getModel().getParent(edge));

                        if (pstate != null) {
                            pt.x -= pstate.origin.x;
                            pt.y -= pstate.origin.y;
                        }

                        pt.x -= this.graph.panDx / this.graph.view.scale;
                        pt.y -= this.graph.panDy / this.graph.view.scale;
                    }

                    geo.setTerminalPoint(pt, isSource);
                    model.setGeometry(edge, geo);
                }
            } finally {
                model.endUpdate();
            }

            return result;
        };
    </script>
    <!--
        Adds in-place highlighting for complete cell area (no hotspot).
    -->
    <script type="text/javascript">
        mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
        mxConnectionHandler.prototype.createMarker = function () {
            var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);

            // Uses complete area of cell for new connections (no hotspot)
            marker.intersects = function (state, evt) {
                return true;
            };

            // Adds in-place highlighting
            mxCellHighlightHighlight = mxCellHighlight.prototype.highlight;
            marker.highlight.highlight = function (state) {
                if (this.state != state) {
                    if (this.state != null) {
                        this.state.style = this.lastStyle;

                        // Workaround for shape using current stroke width if no strokewidth defined
                        this.state.style['strokeWidth'] = this.state.style['strokeWidth'] || '1';
                        this.state.style['strokeColor'] = this.state.style['strokeColor'] || 'none';

                        if (this.state.shape != null) {
                            this.state.view.graph.cellRenderer.configureShape(this.state);
                            this.state.shape.redraw();
                        }
                    }

                    if (state != null) {
                        this.lastStyle = state.style;
                        state.style = mxUtils.clone(state.style);
                        state.style['strokeColor'] = '#FF0000FF';
                        state.style['strokeWidth'] = '3';

                        if (state.shape != null) {
                            state.view.graph.cellRenderer.configureShape(state);
                            state.shape.redraw();
                        }
                    }

                    this.state = state;
                }
            };

            return marker;
        };

        mxEdgeHandlerCreateMarker = mxEdgeHandler.prototype.createMarker;
        mxEdgeHandler.prototype.createMarker = function () {
            var marker = mxEdgeHandlerCreateMarker.apply(this, arguments);

            // Adds in-place highlighting when reconnecting existing edges
            marker.highlight.highlight = this.graph.connectionHandler.marker.highlight.highlight;

            return marker;
        }
    </script>
    <!--
        Adds oval markers for edge-to-edge connections.
    -->
    <script type="text/javascript">
        mxGraphGetCellStyle = mxGraph.prototype.getCellStyle;
        mxGraph.prototype.getCellStyle = function (cell) {
            var style = mxGraphGetCellStyle.apply(this, arguments);

            if (style != null && this.model.isEdge(cell)) {
                style = mxUtils.clone(style);

                if (this.model.isEdge(this.model.getTerminal(cell, true))) {
                    style['startArrow'] = 'oval';
                }

                if (this.model.isEdge(this.model.getTerminal(cell, false))) {
                    style['endArrow'] = 'oval';
                }
            }

            return style;
        };
    </script>
    <!--
        Imlements a custom resistor shape. Direction currently ignored here.
    -->

    <script type="text/javascript">
        function ResistorShape() {
        };
        ResistorShape.prototype = new mxCylinder();
        ResistorShape.prototype.constructor = ResistorShape;

        ResistorShape.prototype.redrawPath = function (path, x, y, w, h, isForeground) {
            var dx = w / 16;

            if (isForeground) {
                path.moveTo(0, h / 2);
                path.lineTo(2 * dx, h / 2);
                path.lineTo(3 * dx, 0);
                path.lineTo(5 * dx, h);
                path.lineTo(7 * dx, 0);
                path.lineTo(9 * dx, h);
                path.lineTo(11 * dx, 0);
                path.lineTo(13 * dx, h);
                path.lineTo(14 * dx, h / 2);
                path.lineTo(16 * dx, h / 2);

                path.end();
            }
        };

        mxCellRenderer.registerShape('resistor', ResistorShape);
    </script>
    <!--
        Imlements a custom resistor shape. Direction currently ignored here.
    -->
    <script type="text/javascript">
        mxEdgeStyle.WireConnector = function (state, source, target, hints, result) {
            // Creates array of all way- and terminalpoints
            var pts = state.absolutePoints;
            var horizontal = true;
            var hint = null;

            // Gets the initial connection from the source terminal or edge
            if (source != null && state.view.graph.model.isEdge(source.cell)) {
                horizontal = state.style['sourceConstraint'] == 'horizontal';
            } else if (source != null) {
                horizontal = source.style['portConstraint'] != 'vertical';

                // Checks the direction of the shape and rotates
                var direction = source.style[mxConstants.STYLE_DIRECTION];

                if (direction == 'north' || direction == 'south') {
                    horizontal = !horizontal;
                }
            }

            // Adds the first point
            // TODO: Should move along connected segment
            var pt = pts[0];

            if (pt == null && source != null) {
                pt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
            } else if (pt != null) {
                pt = pt.clone();
            }

            var first = pt;

            // Adds the waypoints
            if (hints != null && hints.length > 0) {

                for (var i = 0; i < hints.length; i++) {
                    horizontal = !horizontal;
                    hint = state.view.transformControlPoint(state, hints[i]);

                    if (horizontal) {
                        if (pt.y != hint.y) {
                            pt.y = hint.y;
                            result.push(pt.clone());
                        }
                    } else if (pt.x != hint.x) {
                        pt.x = hint.x;
                        result.push(pt.clone());
                    }
                }
            } else {
                hint = pt;
            }

            // Adds the last point
            pt = pts[pts.length - 1];

            // TODO: Should move along connected segment
            if (pt == null && target != null) {
                pt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
            }

            if (horizontal) {
                if (pt.y != hint.y && first.x != pt.x) {
                    result.push(new mxPoint(pt.x, hint.y));
                }
            } else if (pt.x != hint.x && first.y != pt.y) {
                result.push(new mxPoint(hint.x, pt.y));
            }
        };

        mxStyleRegistry.putValue('wireEdgeStyle', mxEdgeStyle.WireConnector);

        // This connector needs an mxEdgeSegmentHandler
        mxGraphCreateHandler = mxGraph.prototype.createHandler;
        mxGraph.prototype.createHandler = function (state) {
            var result = null;

            if (state != null) {
                if (this.model.isEdge(state.cell)) {
                    var style = this.view.getEdgeStyle(state);

                    if (style == mxEdgeStyle.WireConnector) {
                        return new mxEdgeSegmentHandler(state);
                    }
                }
            }

            return mxGraphCreateHandler.apply(this, arguments);
        };
    </script>


</head>
<header th:replace="fragment/headerFragment :: header"></header>

<body onLoad="main(document.getElementById('graphContainer'))">

<table style="position:relative;">
    <tr>
        <td>
            <div id="graphContainer" class="custom_pano">
            </div>
        </td>
        <td valign="top">
            <div id="properties" class="custom_properties">
            </div>
        </td>
    </tr>
</table>

</body>

<div class="modal fade" id="exampleModal" tabIndex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h1 class="modal-title fs-5 m-auto" id="exampleModalLabel"><i class="bi bi-bank"></i>
                    Данные из БД</h1>
                <button type="button" class="btn-close m-none m-revert ml-0" data-bs-dismiss="modal"
                        aria-label="Close"></button>
            </div>
            <div class="modal-body modal-body-size">

                <div class="col-md-12">

                    <div class="tableFixHead">
                        <table id="dataTable"
                               class="table table-dark table-hover table-bordered text-center">
                            <thead class="vertical-align-m">
                            <tr>
                                <th scope="col" hidden="">id</th>
                                <th scope="col">Наименовение элемента</th>
                                <th scope="col">Лямда</th>
                                <th scope="col">Еденица измерения</th>
                            </tr>
                            </thead>
                            <tbody class="table-light" id="dataTable-id">

                            </tbody>
                        </table>
                    </div>

                </div>
            </div>
        </div>
    </div>
</div>
<script type="text/javascript" th:src="@{/webjars/bootstrap/5.3.2/js/bootstrap.bundle.min.js}"></script>
<script type="text/javascript" th:inline="javascript" th:src="@{/js_custom/rest_script.js}"></script>
</html>